---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2019/10/30 10:43
--- 定时器
---

local LuaObject = require("Core.LuaObject")
---@class Timer : Core.LuaObject
---@field New fun(interval:number, handler:Handler)
---@field running boolean
---@field interval number 间隔 (单位：秒)
---@field handler Handler
---@field overHandler Handler
---@field maxCount number
---@field currCount number
local Timer = class("Timer", LuaObject)

---@param interval number
---@param handler Handler
function Timer:Ctor(interval, handler, maxCount, overHandler)
    self.interval = interval
    self.handler = handler
    self.maxCount = maxCount or 0
    self.overHandler = overHandler
    self.updateFunc = function()
        self:Update()
    end
    monoMgr:AddUpdateFun(self.updateFunc)
end

local function getCurrentTime(ignoreTimeScale)
    local time
    if ignoreTimeScale == nil or ignoreTimeScale == false then
        --不忽略时间缩放
        time = Time.time
    else
        --忽略时间缩放 （实际时间）
        time = Time.realtimeSinceStartup
    end
    return time
end

function Timer:Start(ignoreTimeScale)
    if self.running then
        return
    end
    monoMgr:RemoveUpdateFun(self.updateFunc)
    monoMgr:AddUpdateFun(self.updateFunc)
    self.running = true
    self.currCount = 0
    self.ignoreTimeScale = ignoreTimeScale
    self.startTime = getCurrentTime(ignoreTimeScale)
    self.lastTime = self.startTime
end


function Timer:Update()
    if self.running then
        local currTime = getCurrentTime(self.ignoreTimeScale)
        local passTime = currTime - self.lastTime
        local times = Mathf.Floor(passTime / self.interval) --次数
        local count = Mathf.Min(self.currCount + times,self.maxCount)
        if self.maxCount > 0 and count == self.maxCount then
            times = self.maxCount - self.currCount
        end
        self.currCount = count

        if times > 999 then
            times = 1
        end
        for i = 1, times do
            if not self.running then
                break
            end
            if self.handler then
                if isFunction(self.handler) then
                    self.handler()
                else
                    self.handler:Execute()
                end
            end
            self.lastTime = currTime
        end
        if self.maxCount > 0 and self.currCount == self.maxCount then
            self:Stop()
            if self.overHandler then
                if isFunction(self.overHandler) then
                    self.overHandler()
                else
                    self.overHandler:Execute()
                end
            end
        end

    end
end

function Timer:Stop(dispose)
    self.running = false
    monoMgr:RemoveUpdateFun(self.updateFunc)
    if dispose then
        self:Dispose()
    end
end

function Timer:Restart(ignoreTimeScale)
    self.running = false
    self:Start(ignoreTimeScale)
end


function Timer:Dispose()
    self:Stop()
    monoMgr:RemoveUpdateFun(self.updateFunc)
    if self.handler and not isFunction(self.handler) then
        self.handler:Recycl()
    end
    if self.overHandler and not isFunction(self.overHandler) then
        self.overHandler:Recycl()
    end
    self.handler = nil
    self.overHandler = nil
end

return Timer
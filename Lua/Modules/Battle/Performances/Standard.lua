---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zheng.
--- DateTime: 2020/4/18 23:10
--- 标准的表现
---

local BattleItemEvents = require("Game.Modules.Battle.Events.BattleItemEvents")
local PerformanceBase = require("Game.Modules.Battle.Performances.PerformanceBase")
---@class Game.Modules.Battle.Performances.Standard : Game.Modules.Battle.Performances.PerformanceBase
---@field New fun(avatar: Game.Modules.World.Items.BattleUnit):Game.Modules.Battle.Performances.Standard
---@field accountContextList table<number, Game.Modules.World.Contexts.AccountContext>
---@field accounts table<number, AccountInfo>
---@field accountCount number
---@field animCount number
local Standard = class("Game.Modules.Battle.Performances.Standard", PerformanceBase)

function Standard:Ctor(battleUnit, performanceInfo)
    Standard.super.Ctor(self, battleUnit, performanceInfo)
    self.sequenceOver = false
    self.accountContextList = {}
    self.accountCount = 0
    self.animCount = 0
end

---@param sequence DG.Tweening.Sequence
function Standard:OnBeginPerformance(sequence)
    Standard.super.OnBeginPerformance(self, sequence)

    self.skillVo = self.args[1] ---@type Game.Modules.Battle.Vo.SkillVo

    self:StartCoroutine(function()
        self.accounts = self.performanceInfo.accounts
        self:OnProcessStart()
        for i = 1, self.performanceInfo.times do
            self:Process()
            if self.performanceInfo.interval > 0 then
                coroutine.wait(self.performanceInfo.interval / self.battleUnit.context.battleSpeed)
            end
        end
        while self.accountCount < self.performanceInfo.times * #self.accounts do
            coroutine.step(1)
        end
        self:OnAllAccountEnd()
        while self.animCount < self.performanceInfo.times do
            coroutine.step(1)
        end
        self:OnProcessEnd()
        self.sequenceOver = true

    end)
    return true
end

--开始
function Standard:OnProcessStart()

end

function Standard:Process()
    if self.performanceInfo.accountType == AccountType.Single then
        --self.battleUnit:PlayIdle()
        self:AccountProgress(self.performanceInfo.animInfo,function()
            for i = 1, #self.accounts do
                self:DoAccount(self.accounts[i])
            end
        end)
    else
        ---@param account AccountInfo
        self:MultiAccountProgress(self.performanceInfo.animInfo, self.accounts, function(account)
            self:DoAccount(account)
        end)
    end
    self.battleUnit.animCtrl:PlayAnimInfo(self.performanceInfo.animInfo,Handler.New(function()
        self.animCount = self.animCount + 1
    end), self:GetAnimSpeed(self.performanceInfo.animInfo))
end


---@param animInfo AnimInfo
function Standard:AccountProgress(animInfo, accountCallback)
    local animLength = self.battleUnit.animCtrl:GetAnimLength(animInfo.animName)
    self:CreateDelay(animInfo.accountPoint * self:GetAnimLength(animLength, animInfo), accountCallback)
end

---@param animInfo AnimInfo
---@param accounts table<number, AccountInfo>
function Standard:MultiAccountProgress(animInfo, accounts, accountCallback)
    local animLength = self.battleUnit.animCtrl:GetAnimLength(animInfo.animName)
    for i = 1, #accounts do
        self:CreateDelay(accounts[i].accountPoint * self:GetAnimLength(animLength, animInfo), function()
            accountCallback(accounts[i])
        end)
    end
end

---@param animInfo AnimInfo
function Standard:GetAnimLength(animLength, animInfo)
    return math.max(0.1,animLength / self:GetAnimSpeed(animInfo))
end

---@param animInfo AnimInfo
function Standard:GetAnimSpeed(animInfo)
    return animInfo.animSpeed * 1.5 * self.battleUnit.context.battleSpeed
end

---@param account AccountInfo
function Standard:DoAccount(account)
    self.battleUnit.behavior:OnAttackAccount(account)
    self.accountCount = self.accountCount + 1
end

function Standard:OnAllAccountEnd()
    self.battleUnit.behavior:OnAttackAccountEnd()
end

function Standard:OnProcessEnd()

end

--重写阻塞函数
---@param sequence DG.Tweening.Sequence
function Standard:OnWaitPerformance(sequence)
    --等待开始阶段结束
    while not self.sequenceOver do
        coroutine.step(1)
    end
end

function Standard:Dispose()
    Standard.super.Dispose(self)
end

return Standard
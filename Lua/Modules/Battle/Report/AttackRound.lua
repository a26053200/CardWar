---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zheng.
--- DateTime: 2020/7/4 21:07
--- 攻击回合
---

local ReportHurtInfo = require("Game.Modules.Battle.Report.ReportHurtInfo")
---@class Game.Modules.Battle.Report.AttackRound
---@field New fun():Game.Modules.Battle.Report.AttackRound
---@field battleUnit Game.Modules.Battle.Report.ReportBattleUnit
---@field callback fun() | Handler
---@field hurtInfoMap table<string, table<number, Game.Modules.Battle.Report.ReportHurtInfo>>
---@field skill Game.Modules.Battle.Vo.SkillVo
---@field camp string
---@field layoutIndex number
---@field actionRecoveryTP number 行动恢复的TP
---@field targetList table<number, Game.Modules.Battle.Report.ReportBattleUnit>
---@field skillLoopIndex number
local AttackRound = class("Game.Modules.Battle.Report.AttackRound");

local SID = 1

function AttackRound:Ctor(callback)
    self.callback = callback
    self.hurtInfoMap = {}
    self.id = SID
    SID = SID + 1
end

---@param battleUnit Game.Modules.Battle.Report.ReportBattleUnit
function AttackRound:SetBattleUnit(battleUnit)
    self.battleUnit = battleUnit
end

function AttackRound:RoundStart()

end

--回合开始
function AttackRound:RoundStart()
    self:SelectSkill()
    self:AppendSkill()
    --self:RoundEnd()
end

--选择技能
function AttackRound:SelectSkill()
    self.battleUnit:AutoSelectSkill()
end

function AttackRound:AppendSkill()
    self.skill = self.battleUnit.currSelectedSkill
    self.skillLoopIndex = self.battleUnit.skillLoopIndex
    if self.skill == nil then
        self.battleUnit:_debug("当前没有可以使用的技能")
        --self:RoundEnd()
        return
    end
    self:AccountSkill(self.skill)
end

--技能释放
---@param skill Game.Modules.Battle.Vo.SkillVo
function AttackRound:AccountSkill(skill)
    skill.startTime = Time.time
    skill.useCount = skill.useCount + 1
    print(self.battleUnit.battleUnitVo.battleUnitInfo.name .. " 开始攻击 skill:" .. skill.skillInfo.id)

    self:OnAccountBegin(skill)
    self:OnAccountProcess(skill)
    self:OnAccountEnd()
end

---@param skillVo Game.Modules.Battle.Vo.SkillVo
function AttackRound:OnAccountBegin(skillVo)
    local tpRecover = self.battleUnit.battleUnitVo:ActionRecoveryTP()
    self.actionRecoveryTP = tpRecover
    self.battleUnit.battleUnitVo:RecoveryTP(tpRecover)--恢复Tp
end

---@param skillVo Game.Modules.Battle.Vo.SkillVo
function AttackRound:OnAccountProcess(skillVo)
    local performanceInfo = PerformanceConfig.Get(skillVo.skillInfo.performance)
    local accounts = performanceInfo.accounts
    for i = 1, performanceInfo.times do
        for j = 1, #accounts do
            local gridSelect = isEmpty(performanceInfo.gridSelect) and accounts[j].gridSelect or performanceInfo.gridSelect
            local targetCamp = ReportUtils.GetTargetCamp(gridSelect, self.battleUnit) --对立阵营
            local targetGridList = ReportUtils.GetTargetCampAndGrids(gridSelect, targetCamp, self.battleUnit)
            local targetList = self.battleUnit.context.layout:GetTargetList(targetCamp, targetGridList)
            if #targetList > 0 then
                for k = 1, #targetList do
                    local target = targetList[k]
                    if target:IsDead() then

                    else
                        self:DamageAccount(skillVo, accounts[j], target)
                    end
                end
            else
                logError("not target gridSelect:" .. gridSelect)
            end
        end
    end
end


--最终伤害结算
---@param target Game.Modules.Battle.Report.ReportBattleUnit
---@param skillVo Game.Modules.Battle.Vo.SkillVo
---@param account AccountInfo
function AttackRound:DamageAccount(skillVo, account, target)
    --是否增益结算 例如加血  上buff等
    local isHelpful = account.targetMode == TargetMode.Self or account.targetMode == TargetMode.Friend
    local battleUnitVo = self.battleUnit.battleUnitVo
    local minDam = 1
    local unitAttribute = battleUnitVo.attribute --单位属性
    local hurtInfo = ReportHurtInfo.New()
    hurtInfo.atker = copy(self.battleUnit.battleUnitVo)
    hurtInfo.defer = copy(target.battleUnitVo)
    hurtInfo.skill = skillVo
    hurtInfo.accountId = account.id
    hurtInfo.isHelpful = isHelpful
    --伤害计算 (技能提供伤害*技能等级+面板魔法/物理攻击*技能倍率)
    if skillVo.skillInfo.attackType == AttackType.Physic then
        hurtInfo.atk = skillVo.skillInfo.damage * skillVo.level + unitAttribute.p_atk * (skillVo.skillInfo.damageAdd + 1) * (account.damageRatio / 1)
        hurtInfo.def = target.battleUnitVo.attribute.p_def
        hurtInfo.crit = (math.random() < unitAttribute.p_crit) and 2 or 1 --暴击
    else
        hurtInfo.atk = skillVo.skillInfo.damage * skillVo.level + unitAttribute.m_atk * (skillVo.skillInfo.damageAdd + 1) * (account.damageRatio / 1)
        hurtInfo.def = target.battleUnitVo.attribute.m_def
        hurtInfo.crit = (math.random() < unitAttribute.m_crit) and 2 or 1 --暴击
    end
    --伤害=攻击力/ ( 1 +防御力/ 100 )
    hurtInfo.dam = math.floor(math.max(minDam, hurtInfo.atk / (1 + hurtInfo.def / 100)))
    hurtInfo.acc = math.random() --命中率
    local isMiss = false
    --计算闪避
    --local signet = target.signetMap[self.battleUnit.sid .. "_" .. skillInfo.id]
    --if hurtInfo.acc > self.battleUnit.avatarInfo.acc
    --        or signet == SignetType.Dodge then
    --    isMiss = true
    --end
    --if signet ~= nil then
    --    target.performancePlayer:Play(account.signetPerformance,nil,self.battleUnit, account)
    --end
    if isMiss then
        hurtInfo.miss = true
        --print("miss")
        if target then
            target:DoHurt(hurtInfo)
            target.battleUnitVo:DamageRecoveryTP(hurtInfo.dam)--恢复Tp
        end
        return
    end
    hurtInfo.miss = false
    if target then
        local tpRecover = target.battleUnitVo:DamageRecoveryTP(hurtInfo.dam)
        target.battleUnitVo:RecoveryTP(tpRecover)--恢复Tp
        if isHelpful then
            target.battleUnitVo.curHp = math.min(target.battleUnitVo.curHp + hurtInfo.dam, target.battleUnitVo.maxHp)
        else
            target.battleUnitVo.curHp = math.max(0,target.battleUnitVo.curHp - hurtInfo.dam)
        end
        hurtInfo.damRecoveryTP = tpRecover
    end
    print(string.format("Skill:%s Atker:<color=#FFFFFFFF>%s</color> atk Defer:<color=#FFFFFFFF>%s</color> - dam:<color=#FFFF00FF>%s</color> (%2f)",
            hurtInfo.skill.skillInfo.id,
            hurtInfo.atker:GetDebugName(),
            hurtInfo.defer:GetDebugName(),
            hurtInfo.dam, (target.battleUnitVo.curHp)))
    if target:IsDead() then
        hurtInfo.deferIsDead = true
        --self.battleUnit.context:RemoveBattleUnit(target.battleUnitVo.camp, target.battleUnitVo.layoutIndex)
        print(string.format("<color=#FF0000FF>%s</color> is Dead",target.debugName))
    end
    local hurtList = self.hurtInfoMap[account.id]
    if hurtList == nil then
        hurtList = List.New()
        self.hurtInfoMap[account.id] = hurtList
    end
    hurtList:Add(hurtInfo)
end

---@param skillVo Game.Modules.Battle.Vo.SkillVo
function AttackRound:OnAccountEnd(skillVo)

end

---@return Game.Modules.Battle.Report.Nodes.ReportNode
function AttackRound:GetReportNode()
    local json = {}
    json.id = self.id
    json.camp = self.battleUnit.battleUnitVo.camp
    json.layoutIndex = self.battleUnit.battleUnitVo.layoutIndex
    json.actionRecoveryTP = self.actionRecoveryTP
    json.skillId = self.skill.skillInfo.id
    json.skillLevel = self.skill.level
    return json
end

---@return table<number, Game.Modules.Battle.Report.Nodes.AccountNode>
function AttackRound:GetAccountNodes()
    local reportNodes = {}
    for accountId, hurtList in pairs(self.hurtInfoMap) do
        for i = 1, hurtList:Size() do
            local node = {} ---@type Game.Modules.Battle.Report.Nodes.AccountNode
            node.pid =              self.id
            node.accountId =        accountId
            node.atkerId =          hurtList[i].atker.sid
            node.deferId =          hurtList[i].defer.sid
            node.damRecoveryTP =    hurtList[i].damRecoveryTP
            node.isHelpful =        hurtList[i].isHelpful
            node.dam =              hurtList[i].dam
            node.critDam =          hurtList[i].critDam
            node.atk =              hurtList[i].atk
            node.def =              hurtList[i].def
            node.crit =             hurtList[i].crit
            node.miss =             hurtList[i].miss
            node.acc =              hurtList[i].acc
            table.insert(reportNodes, node)
        end
    end
    return reportNodes
end

--回合结束
function AttackRound:RoundEnd()
    invoke(self.callback)
end

return AttackRound
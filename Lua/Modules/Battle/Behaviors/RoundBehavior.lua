---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2020/2/25 15:03
--- 回合制。计算谁先攻击；回合时间的暂停的继续
---

local BattleEvent = require("Game.Modules.Battle.Events.BattleEvents")
local BaseBehavior = require("Game.Modules.Common.Behavior.BaseBehavior")

---@class Module.Battle.Behaviors.RoundBehavior : Game.Modules.Common.Behavior.BaseBehavior
---@field New fun(context:WorldContext):Module.Battle.Behaviors.RoundBehavior
---@field currArea Game.Modules.Battle.Layouts.GridArea
---@field context WorldContext
---@field currRoundAvatar Game.Modules.World.Items.Avatar 当前回合的Avatar
---@field totalAttackNum number
---@field isRoundOver boolean
---@field isPause boolean
---@field attackSortList List | table<number, Game.Modules.World.Items.Avatar>
---@field waitAttackOver boolean
---@field mode RoundMode
---@field manualCamp Camp 手动模式攻击的阵营
---@field manualLayoutIndex number 手动模式攻击索引
---@field manualSkillName string 手动模式使用的技能
local RoundBehavior = class("Module.Battle.Behaviors.GridBattleBehavior",BaseBehavior)

---@param context WorldContext
function RoundBehavior:Ctor(context)
    RoundBehavior.super.Ctor(self)

    self:AppendBehavior(self:RoundStart(),      "AvatarGridBehavior RoundStart")
    self:AppendBehavior(self:RoundProgress(),   "AvatarGridBehavior RoundProgress")
    self:AppendBehavior(self:RoundEnd(),        "AvatarGridBehavior RoundEnd")
    self.context = context

    AddEventListener(BattleEvent, BattleEvent.ExitAttack, self.OnExitAttack, self)
    AddEventListener(BattleEvent, BattleEvent.BattlePause, self.OnBattlePause, self)
    self.isRoundOver = true
    self.attackSortList = List.New()
    --手动开启一轮攻击
    self.context.luaReflect:PushLuaFunction("ManualAttack",handler(self, self.ManualAttack))
end

---@param event Game.Modules.Battle.Events.BattleEvents
function RoundBehavior:OnBattlePause(event)
    if self.currRoundAvatar then
        self.currRoundAvatar:SetBehaviorEnabled(false)
    end
end

---@param mode RoundMode
function RoundBehavior:RoundStart(mode)
    self.mode = mode
end

--手动模式
---@param camp Camp
---@param layoutIndex number
function RoundBehavior:ManualAttack(camp, layoutIndex, skillName)
    if self:isRunning() then
        print("isRunning")
    else
        self.manualCamp = camp
        self.manualLayoutIndex = layoutIndex
        self.manualSkillName = skillName
        self:RoundStart(RoundMode.Manual)
        self.loop = false
        self:Play()
    end
end

--重置攻击队列
function RoundBehavior:ResetAttackSortArray()
    self.attackSortList:Clear()
    if self.mode == RoundMode.Auto then
        --测试时，随机攻击顺序
        local tempList = List.New()
        tempList:Concat(self.context.battleBehavior:GetCampAvatarList(Camp.Atk))
        tempList:Concat(self.context.battleBehavior:GetCampAvatarList(Camp.Def))
        self.totalAttackNum = tempList:Size()
        local randoms = Tool.GetRandomArray(self.totalAttackNum)
        for i = 1, #randoms do
            self.attackSortList:Add(tempList[randoms[i]])
        end
    else
        self.totalAttackNum = 1
        local grid = self.context.battleLayout:GetLayoutGridByIndex(self.manualCamp,self.manualLayoutIndex)
        grid.owner.strategy:SetNecessarySkill(self.manualSkillName)
        self.attackSortList:Add(grid.owner)
    end
end

--暂停回合
function RoundBehavior:Pause()
    self.isPause = true
end

--恢复
function RoundBehavior:Resume()
    self.isPause = false
end

function RoundBehavior:OnExitAttack()
    self.waitAttackOver = false
end

--回合开始阶段
--排序整个回合的攻击队列
function RoundBehavior:RoundStart()
    local behavior = self:CreateSubBehavior()
    behavior:AppendState(function()
        if self.isRoundOver then
            self.isRoundOver = false
            self:_debug("RoundBehavior RoundStart")
            self:ResetAttackSortArray()
        end
        self:NextState()
    end)
    return behavior
end


--按队列进行攻击
function RoundBehavior:RoundProgress()
    local behavior = self:CreateSubBehavior()
    behavior:AppendState(function()
        self:StartCoroutine(function()
            self:_debug("RoundBehavior RoundProgress " .. self.attackSortList:Size() .. "/" .. self.totalAttackNum)
            --等待暂停
            while self.isPause do
                coroutine.step(1)
            end
            local currAvatar = self.attackSortList:Shift() ---@type Game.Modules.World.Items.Avatar
            if currAvatar and not currAvatar:IsDead() then
                currAvatar:SetBehaviorEnabled(true)
                self.waitAttackOver = true
                while self.waitAttackOver do
                    coroutine.step(1)
                end
                self.currRoundAvatar = currAvatar
            end
            self:NextState()
        end)
    end)
    return behavior
end

--回合结束阶段
function RoundBehavior:RoundEnd()
    local behavior = self:CreateSubBehavior()
    behavior:AppendState(function()
        if self.attackSortList:Size() == 0 then
            self.isRoundOver = true
            self:_debug("RoundBehavior RoundEnd")
        end
        self.currRoundAvatar = nil
        if self.loop then
            self:NextState()
        else
            self.isRoundOver = true
            self:Stop()
        end
    end)
    return behavior
end

function RoundBehavior:Stop()
    RoundBehavior.super.Stop(self)
    --剩下的单位都停止行为
    local tempList = List.New()
    tempList:Concat(self.context.battleBehavior:GetCampAvatarList(Camp.Atk))
    tempList:Concat(self.context.battleBehavior:GetCampAvatarList(Camp.Def))
    for i = 1, tempList:Size() do
        if not tempList[i]:IsDead() then
            tempList[i]:SetBehaviorEnabled(false)
        end
    end
    self.attackSortList:Clear()
end

function RoundBehavior:Dispose()
    RoundBehavior.super.Dispose(self)
    RemoveEventListener(BattleEvent, BattleEvent.ExitAttack, self.OnExitAttack, self)
    RemoveEventListener(BattleEvent, BattleEvent.BattlePause, self.OnBattlePause, self)
end

return RoundBehavior
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2019/5/27 12:51
---

local AStarUtils = {}

---@class AroundNode
---@field ownerSid number
---@field node AStar.Node

---@param startPos UnityEngine.Vector3
---@param dstPos UnityEngine.Vector3
function AStarUtils.RequestPath(startPos, dstPos, callback, failCallback, smooth)
    local aStar = AStar.PathRequestManager
    aStar.RequestPath(startPos, dstPos, 5, 10, smooth, function(path)
        local pathList = {}
        for i = 0, path.lookPoints.Length - 1 do
            table.insert(pathList, path.lookPoints[i])
        end
        callback(pathList)
    end, function()
        if failCallback then
            failCallback()
        end
    end)
end

-- 获取附近的格子节点
---@param grid AStar.Grid
---@param node AStar.Node
---@return table<number, AroundNode>
function AStarUtils.GetNeighbourNodes(grid, node, r)
    local nodes = {}
    r = r == nil and 1 or r
    for x = -r, r do
        for y = -r, r do
            if not (x == 0 and y == 0) then
                local checkX = node.gridX + x;
                local checkY = node.gridY + y;
                if checkX >= 0 and checkX < grid.gridSizeX and checkY >= 0 and checkY < grid.gridSizeY then
                    local node = grid:GetNode(checkX, checkY)
                    if node.walkable then
                        table.insert(nodes, { node = node, ownerSid = 0 })
                    end
                end
            else
                table.insert(nodes, { node = node, ownerSid = 0 })
            end
        end
    end
    return nodes
end

-- 获取空格子
---@param src Game.Modules.Battle.Items.Avatar
---@param anodes table<number, AroundNode>
---@return table<number, AroundNode>
function AStarUtils.GetDistanceNodes(src, anodes, distance)
    local nodes = {}
    for i = 1, #anodes do
        local d = AStarUtils.NodeDistance(src.currNode, anodes[i].node)
        if d == distance then
            table.insert(nodes, anodes[i])
        end
    end
    return nodes
end

-- 获取空格子
---@param src Game.Modules.Battle.Items.Avatar
---@param nodes table<number, AroundNode>
---@return AroundNode
--function AStarUtils.GetAroundEmptyNode(nodes)
--    local node
--    local randoms = Tool.GetRandomArray(#nodes)
--    for i = 1, #nodes do
--        if not World.IsOverlapHeroNode(nodes[randoms[i]].node) then
--            node = nodes[i].node
--        end
--    end
--    return node
--end

-- 获取目标点数组最近的格子节点
---@param src Game.Modules.Battle.Items.Avatar
---@param nodes table<number, AroundNode>
---@return AroundNode
function AStarUtils.GetAroundNearestNode(src, nodes)
    local minDistance = Mathf.Infinity
    local GetNode = function(checkInWalking)
        local node
        for i = 1, #nodes do
            if checkInWalking ~= true or (checkInWalking == true and (nodes[i].node.inWalkingSid <= 0 or nodes[i].node.inWalkingSid == src.avatarInfo.sid)) then
                local distance = Vector3.Distance(src.transform.position, nodes[i].node.worldPosition)
                if distance < minDistance then
                    minDistance = distance
                    node = nodes[i]
                end
            end
        end
        return node
    end

    -- 优先取不重叠的格子
    local node = GetNode(true)
    -- 没有不重叠的格子再取最近的格子
    if not node and #nodes > 0 then
        node = GetNode(false)
    end

    return node
end

-- 获取目标点数组最近的格子节点
---@param src Game.Modules.Battle.Items.Avatar
---@param points table<number, Framework.AroundPoint>
---@return Framework.AroundPoint
function AStarUtils.GetAroundNearestPoint(src, points)
    local minDistance = Mathf.Infinity
    local GetNode = function(checkInWalking)
        local point
        for i = 0, points.Length - 1 do
            if checkInWalking ~= true or (points[i].walkable
                    and checkInWalking == true
                    and (points[i].owner <= 0 or points[i].owner == src.avatarInfo.sid)) then
                local distance = Vector3.Distance(src.transform.position, points[i].pos)
                if distance < minDistance then
                    minDistance = distance
                    point = points[i]
                end
            end
        end
        return point
    end

    -- 优先取不重叠的格子
    local point = GetNode(true)
    -- 没有不重叠的格子再取最近的格子
    if not point and #points > 0 then
        point = GetNode(false)
    end

    return point
end

-- 获取目标点数组最近的格子节点
---@param src UnityEngine.Vector3
---@param nodes table<number, AroundNode>
---@return AroundNode
function AStarUtils.GetAroundNearestNodePos(src, nodes)
    local minDistance = Mathf.Infinity
    local GetNode = function(checkInWalking)
        local node
        for i = 1, #nodes do
            if checkInWalking ~= true or (checkInWalking == true and (nodes[i].node.inWalkingSid <= 0 or nodes[i].node.inWalkingSid == src.avatarInfo.sid)) then
                local distance = Vector3.Distance(src, nodes[i].node.worldPosition)
                if distance < minDistance then
                    minDistance = distance
                    node = nodes[i]
                end
            end
        end
        return node
    end

    -- 优先取不重叠的格子
    local node = GetNode(true)
    -- 没有不重叠的格子再取最近的格子
    if not node and #nodes > 0 then
        node = GetNode(false)
    end

    return node
end

-- 获取目标点数组最远的格子节点
---@param src Game.Modules.Battle.Items.Avatar
---@param nodes table<number, AStar.Node>
---@return AroundNode
function AStarUtils.GetAroundFarestNode(src, nodes)
    local maxDistance = 0
    local GetNode = function(checkInWalking)
        local node
        for i = 1, #nodes do
            if checkInWalking ~= true or (checkInWalking == true and (nodes[i].node.inWalkingSid <= 0 or nodes[i].node.inWalkingSid == src.avatarInfo.sid)) then
                local distance = Vector3.Distance(src.transform.position, nodes[i].node.worldPosition)
                if distance > maxDistance then
                    maxDistance = distance
                    node = nodes[i]
                end
            end
        end
        return node
    end

    -- 优先取不重叠的格子
    local node = GetNode(true)
    -- 没有不重叠的格子再取最远的格子
    if not node and #nodes > 0 then
        node = GetNode(false)
    end

    return node
end


-- 获取随机格子节点
---@param nodes table<number, AStar.Node>
---@return AroundNode
function AStarUtils.GetAroundRandomNode(nodes, mySid)
    local idx = math.random(1, #nodes)
    local cur, max = 1, 3   -- 最多随机max次，到上限则取最近的一次
    while (nodes[idx].node.inWalkingSid > 0 and nodes[idx].node.inWalkingSid ~= mySid) do
        idx = math.random(1, #nodes)
        cur = cur + 1
        if cur > max then
            break
        end
    end
    return nodes[idx]
end

-- 节点相等
---@param node1 AStar.Node
---@param node2 AStar.Node
---@return boolean
function AStarUtils.EqualNode(node1, node2)
    return node1.gridX == node2.gridX and node1.gridY == node2.gridY
end

-- 节点相等
---@param grid AStar.Grid
---@param pos1 UnityEngine.Vector3
---@param pos2 UnityEngine.Vector3
---@return boolean
function AStarUtils.PosEqualNode(grid, pos1, pos2)
    return AStarUtils.EqualNode(grid:NodeFromWorldPoint(pos1), grid:NodeFromWorldPoint(pos2))
end

-- 节点距离
---@param node1 AStar.Node
---@param node2 AStar.Node
---@return number
function AStarUtils.NodeDistance(node1, node2)
    local dx = Mathf.Abs(node1.gridX - node2.gridX)
    local dy = Mathf.Abs(node1.gridY - node2.gridY)
    local d = Mathf.Max(dx, dy)
    return d
end

-- 节点距离
---@param grid AStar.Grid
---@param pos UnityEngine.Vector3
---@return boolean
function AStarUtils.Walkable(grid, pos)
    local node = grid:NodeFromWorldPoint(pos)
    return node.walkable
end

-- 两点之间刚好是九宫格
---@param grid AStar.Grid
---@param node1 AStar.Node
---@param node2 AStar.Node
---@return AStar.Node
function AStarUtils.GetNineGridMoveNode(grid, node1, node2)
    local dx = node2.gridX - node1.gridX
    local dy = node2.gridY - node1.gridY
    return grid:GetNode(node1.gridX + dx, node1.gridY + dy)
end

-- 获取目标身后的6个点
---@param grid AStar.Grid
---@param tag UnityEngine.GameObject
---@return table<number, UnityEngine.Vector3>
function AStarUtils.GetBehindPoints(grid, tag)
    local r = grid.nodeRadius
    local p0 = tag.transform.position
    local p = {}
    p[1] = p0 + -tag.transform.forward * r --后
    p[2] = p0 + -tag.transform.forward * r + -tag.transform.right * r * 2 --后左
    p[3] = p0 + -tag.transform.forward * r + tag.transform.right * r * 2 --后右
    p[4] = p0 + -tag.transform.forward * 2 * r --后2
    p[5] = p0 + -tag.transform.forward * 2 * r + -tag.transform.right * r * 2 --后2左
    p[6] = p0 + -tag.transform.forward * 2 * r + tag.transform.right * r * 2 --后2右
    return p
end

-- 获取某方向某距离的可行走点
---@param grid AStar.Grid
---@param startPos UnityEngine.Vector3
---@param dir UnityEngine.Vector3
---@param distance number
---@return UnityEngine.Vector3
function AStarUtils.GetDirctionNode(grid, startPos,dir,distance)
    local r = grid.nodeRadius
    local pos = startPos
    local sum = 0
    while sum <= distance do
        if not grid:NodeFromWorldPoint(pos).walkable then
            break;
        end
        sum = sum + r
        pos = startPos + dir * sum
    end
    return pos
end


return AStarUtils
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2018/11/22 15:50
---
---

local LuaObject = require("Betel.LuaObject")

---@class Game.Modules.Common.Sound.Sound : Betel.LuaObject
---@field New fun(prefab:Game.Modules.Common.Sound.SoundConfig, gameObject:UnityEngine.GameObject, audioSourceParams:table<string,any>):Game.Modules.Common.Sound.Sound
---@field gameObject UnityEngine.GameObject
---@field audioClip UnityEngine.AudioClip
---@field audioSource UnityEngine.AudioSource
---@field soundInfo Game.Modules.Common.Sound.SoundConfig
local Sound = class("Game.Modules.Common.Sound.Sound", LuaObject)

function Sound:Ctor(soundInfo, gameObject, initVolume, audioSourceParams)
    self.soundInfo = soundInfo
    self.gameObject = gameObject
    self.audioSourceParams = audioSourceParams
    self.initVolume = initVolume

    self.num = 1 --第一次播放
    self.destVolume = self.initVolume * self.soundInfo.volumeScale
    self.loadState = "none"
end

function Sound:LoadSound()
    --print("Sound is loading ... " .. self.soundInfo.file)
    --AddEventListener(Res, LoadResEvent.COMPLETE, self.OnSoundLoaded,self)
    Res.LoadAudioClipAsync(self.soundInfo.file, Handler.Get(self.OnSoundLoaded, self))
    self.loadState = "loading"
end

function Sound:OnSoundLoaded(audioClip,a)
    --print("Sound is load complete " .. self.soundInfo.file)
    --if event.assetPath == self.soundInfo.file then
        --RemoveEventListener(Res, LoadResEvent.COMPLETE, self.OnSoundLoaded,self)
        self.loadState = "loaded"
        self.audioClip = audioClip
        self:Play(audioClip)
    --end
end

--创建音源
function Sound:CreateOrPlay()
    if self.loadState == "loaded" then
        self:Play(self.audioClip)
    elseif self.loadState == "none" then
        self:LoadSound()
    else
        print("Sound is loading ... " .. self.soundInfo.file)
    end
    return self
end

--创建音源
function Sound:Play(audioClip)
    self.audioSource = self.gameObject:AddComponent(typeof(UnityEngine.AudioSource))
    self.audioSource.spatialBlend = self.soundInfo.blend
    self.audioSource.rolloffMode = UnityEngine.AudioRolloffMode.Linear
    self.audioSource.minDistance = tonumber(self.soundInfo.minDistance)
    self.audioSource.maxDistance = tonumber(self.soundInfo.maxDistance)
    self.audioSource.clip = audioClip; ---Res.LoadAudioClip(self.soundInfo.file)
    self.audioSource.time = self.soundInfo.beginTime
    self.audioSource.loop = self.soundInfo.loopType == "Loop"
    self.audioSource.playOnAwake = false
    self.audioSource.volume = self.destVolume

    if self.audioSourceParams then
        for k, v in pairs(self.audioSourceParams) do
            self.audioSource[k] = v
        end
    end
    --print("<color=green>[Sound]</color> Create:"..self.soundInfo.intrc.." "..self.soundInfo.file)
    self:FadeIn()
    return self
end

function Sound:SetSoundVolume(volume)
    if not isnull(self.audioSource) then
        self.destVolume = volume * self.soundInfo.volumeScale
        self.audioSource.volume = self.destVolume
    end
end

--淡入
function Sound:FadeIn(callback)
    if isnull(self.audioSource) then
        if callback then
            callback(self)
        end
        return
    end
    if self.fadeOut then
        self.fadeOut:Kill(true)
    end
    local fadeIn = tonumber(self.soundInfo.fadeIn)
    if fadeIn > 0 then
        if self.fadeIn then
            self.fadeIn:Kill(true)
        end
        self.audioSource.volume = 0
        self.audioSource:Play()
        self.fadeIn = self.audioSource:DOFade(self.destVolume, fadeIn):OnComplete(function ()
            if callback then
                callback(self)
            end
        end)
    else
        self.audioSource.volume = self.destVolume
        self.audioSource:Play()
        if callback then
            callback(self)
        end
    end
end

--淡出
function Sound:FadeOut(callback)
    if isnull(self.audioSource) then
        if callback then
            callback(self)
        end
        return
    end
    if self.fadeIn then
        self.fadeIn:Kill(true)
    end
    local fadeOut = tonumber(self.soundInfo.fadeOut)
    if fadeOut > 0 then
        if self.fadeOut then
            self.fadeOut:Kill(true)
        end
        self.fadeOut = self.audioSource:DOFade(0, fadeOut):OnComplete(function()
            if self.audioSource and not isnull(self.audioSource) then
                self.audioSource:Stop()
            end
            if callback then
                callback(self)
            end
        end)
    else
        if self.audioSource and not isnull(self.audioSource) then
            self.audioSource:Stop()
        end
        if callback then
            callback(self)
        end
    end
end

function Sound:Stop()
    if self.audioSource and not isnull(self.audioSource) then
        self.audioSource:Stop()
    end
end

function Sound:Dispose()
    if self.fadeIn then
        self.fadeIn:Kill(true)
    end
    if self.fadeOut then
        self.fadeOut:Kill(true)
    end
    --RemoveEventListener(Res, LoadResEvent.COMPLETE, self.OnSoundLoaded,self)
    if not isnull(self.audioSource) then
        Destroy(self.audioSource)
    end
    self.audioClip = nil
end

return Sound